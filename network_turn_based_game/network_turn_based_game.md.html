<meta charset="utf-8" emacsmode="-*- markdown -*-"><style class="fallback">body{visibility:hidden}</style><link rel="stylesheet" href="../css_templates/blue_template.css">

                            **The network protocol of my C++ turn-based game.**

Hello, I recently learned the basics of network programming in a course module at SAE Institute Geneva. 
I had to put this knowledge into practice to create a small turn-based network game using the SFML library and TCP sockets, 
all in three weeks. 
So I created my very first network protocol to communicate data between the various clients of my game and my server.

I chose to make a 8-ball pool game using my own 2D physics engine. 
I've set up a lobby system that allows several games to be played simultaneously by several clients on the server. 
I also have a database that stores the username and elo of each player connecting to the game.

![Demo of my 8-ball pool <br> It shows two players (blue and red windows) playing a game in network](videos/demo.mp4)

I'm only going to present the protocol I've created for my game, based on Tcp sockets supplied by SFML. 
I'm only going to talk about the application layer, since my protocol is located there.
If you're interested in the transport and network layers, please refer to the SFML documentation.
With that being said, let's get into it.

Packet types.
===============================================================================

The basis of my protocol is an enum called PacketType, 
which differentiates the different packets and allows correct interaction with each of them.

PacketType:

- kNone 
- kClientIdentification,
- kJoinLobby,
- KStartGame,
- kNewTurn,
- KCueBallVelocity,
- kEndGame,
- kEloUpdated,

The first piece of data contained in a packet is always a PacketType so that the way in which the rest of the packet's 
data is read can be adapted. <br>
Here is a small example in pseudo-code for sending a packet:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
sf::Packet my_packet{};
my_packet << PacketType << any_type_of_data;
client_network_interface_->SendPacket(my_packet);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

And here is a small example in pseudo-code for receiving and decoding a packet:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
sf::Packet received_packet;
const auto packet_type = client_network_interface_->ReceivePacket(received_packet);
switch (packet_type) {
  case PacketType::kNone:
    std::cerr << "Packet received has no type. \n";
    break;
  case PacketType::kJoinLobby:
  case PacketType::kClientIdentification: 
  case PacketType::kEloUpdated:
  case PacketType::KStartGame:
  case PacketType::kNewTurn:
  case PacketType::KCueBallVelocity:
  case PacketType::kEndGame:
    // Do what whatever you need to do
    break;
  default:
    break;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Client connection and identification.
===============================================================================

When a user launches the client application, it connects its socket to the server using SFML-Network. 
Once the connection has been made, the client application is in the user identification state. 
In other words, the application asks the user to identify himself by giving a use name. 

![Demo of client identification in my app.](gifs/client_identification.gif width=300 height=450)

When the user has typed a name, a packet of type kClientIdentification containing the name string is sent to the server. The server then makes an HTTP request to the database to retrieve the player's elo. There are two scenarios.

1. The username is already in the database, so the server retrieves the player's elo.
2. The username is not in the database, so the server creates a new player with this name and a base elo of 1000. 

The server then sends the client a packet of type kClientIdentification containing the client's username and elo. 
When the client receive this packet the client-application switches to the main-menu state.
This mechanism for returning the same type of packet guarantees that the client is properly logged in and identified, 
and that he can now use his application freely. 
It also makes it possible to reuse an existing packet type limit the size of the PacketType enumeration.

Joining a lobby.
===============================================================================
When the user presses the play button on the main menu, this sends a KJoinLobby packet to the server containing his username.
The server will look for the first free lobby and add to it a ClientData object containing the player's username and 
the port number on which the packets arrive.

Once the sucessfuly player has been added to the lobby, the server sends back a packet of type kJoinLobby 
so that the client is aware that it is indeed in a lobby, and the application switches to lobby GUI and state.

![Demo of two clients joining a lobby.](gifs/lobby.gif height=450)

Starting a game.
===============================================================================

When the server adds a second customer to a lobby, the lobby is complete and a game can be started. 
The server will create a packet of type kStartGame containing the value "true" and a player index for each client. 
The "true" value is used by the client to initialize its game, and the player index is used to differentiate between the players, 
giving them different colors (blue and red), for example.
The server also send a packet of type kNewTurn to the first player to enables him to play. 
The clients simply retreive the data of the packet, their application initialize a new game object, switch to game state
and the 8-ball pool game can start.

In-game packet communications.
===============================================================================

There is only two different packet types used in my gameplay logic. <br> 
You already know the first one which is a 
kNewTurn packet. This packet only contains a boolean to update the player logic that tells if the player can play or not.
This packet is send to the server which will resend it to the other client when a player has played and the physics simulation 
is finished (when all ball have a velocity lower than an epsilon value). <br> <br>

The second packet type is KCueBallVelocity. A packet of this type is sent to the server when a client has strikes the ball.
Something important is that the client don't simulates the physics right after striking the ball. It needs to wait for the 
server's response to updates the physics a deterministic amount of time to have the exact same simulation as the other client.
This server answer corresponds to antoher KCueBallVelocity sent to the two clients. So when a client receive this type of
packet, it will update the physics until all balls have a velocity greater than an epsilon value.

If the client don't wait for the server to simulate the physics, the would not have the same simulation. That's why
this response from the server is very important.

![Old version of my game when the clients don't wait the response from the server to 
simulate the physics. The more the game last, the more the physics desyncrhonization can be seen.](videos/physics_bug.mp4)

End of game and update of players' elo.
===============================================================================

The last part of my protocol consists in ending the game and updating the elo of each player.
If you are not a beginner in network, you know that you must let the client less control on the game state possible 
otherwise the user could change the code and cheat on your game. But when I created my game, as I said, it was the my first
time writing network code and I sadly did that the client tells the server that he wons. So when a player has put the last 
ball in a hole, he sends a packet of type kEndGame with a boolean value telling telling that he won. The server receive the packet
and send a kEndGame packet with a "false" value to the other client to tell him that he lost.

Then the server updates the elo of each client in the database based on their result and sends a packet of type kEloUpdated
to each client with their new elo. When the client receive the kEloUpdated packet, it activtes the end game menu. 

In the case where a player quite the game before it is finished, the other player automatically win the game and 
both player's elo are updated.

![Demo of a player winning the game + the ability to restart a game easily.](videos/end_game.mp4)

Conclusion.
===============================================================================

My protocol is cleary not perfect. As I said before, the client has too much control on the game state 
which is very unsafe. Despite that, I find the idea of ​​reusing the same type of packet to communicate in both directions 
of the network (client->server server->client) smart enough not to double the number of variables in my enum.
To upgrade my program I would make my server more authorative. It means that I would need to simulate the physics in 
the server side too and check the physic state of the clients. Based on that, the server would be able to tell to which one the 
turn is and which player won the game. 

My network API documentation.
===============================================================================

If you are intersted in my network API for my game, you can check the documentation : <br>
[turn-based game API documentation](../network_api_doc/html/index.html)

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
