<meta charset="utf-8" emacsmode="-*- markdown -*-"><style class="fallback">body{visibility:hidden}</style><link rel="stylesheet" href="../css_templates/blue_template.css">

                            **The network protocole of my C++ turn-based game.**

Hello, I recently learned the basics of network programming in a course module at SAE Institute Geneva. 
I had to put this knowledge into practice to create a small turn-based network game using the SFML library and TCP sockets, 
all in three weeks. 
So I created my very first network protocol to communicate data between the various clients of my game and my server.

I chose to make a 8-ball pool game using my own 2D physics engine. 
I've set up a lobby system that allows several games to be played simultaneously by several clients on the server. 
I also have a database that stores the username and elo of each player connecting to the game.

![Demo of my 8-ball pool <br> It shows two players (blue and red windows) playing a game in network](videos/demo.mp4)

I'm only going to present the protocol I've created for my game, based on Tcp sockets supplied by SFML. 
I'm only going to talk about the application layer, since my protocol is located there.
If you're interested in the transport and network layers, please refer to the SFML documentation.
With that being said, let's get into it.

Packet types.
===============================================================================

The basis of my protocol is an enum called PacketType, 
which differentiates the different packets and allows correct interaction with each of them.

PacketType:

- kNone 
- kClientIdentification,
- kJoinLobby,
- KStartGame,
- kNewTurn,
- KCueBallVelocity,
- kEndGame,
- kEloUpdated,

The first piece of data contained in a packet is always a PacketType so that the way in which the rest of the packet's 
data is read can be adapted. <br>
Here is a small example in pseudo-code for sending a packet:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
sf::Packet my_packet{};
my_packet << PacketType << any_type_of_data;
client_network_interface_->SendPacket(my_packet);
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

And here is a small example in pseudo-code for receiving and decoding a packet:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ c++
sf::Packet received_packet;
const auto packet_type = client_network_interface_->ReceivePacket(received_packet);
switch (packet_type) {
  case PacketType::kNone:
    std::cerr << "Packet received has no type. \n";
    break;
  case PacketType::kJoinLobby:
  case PacketType::kClientIdentification: 
  case PacketType::kEloUpdated:
  case PacketType::KStartGame:
  case PacketType::kNewTurn:
  case PacketType::KCueBallVelocity:
  case PacketType::kEndGame:
    // Do what whatever you need to do
    break;
  default:
    break;
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 

Client connection and identification.
===============================================================================

When a user launches the client application, it connects its socket to the server using SFML-Network. 
Once the connection has been made, the client application is in the user identification state. 
In other words, the application asks the user to identify himself by giving a use name. 

![Demo of client identification in my app.](gifs/client_identification.gif width=300 height=450)

When the user has typed a name, a packet of type kClientIdentification containing the name string is sent to the server. The server then makes an HTTP request to the database to retrieve the player's elo. There are two scenarios.

1. The username is already in the database, so the server retrieves the player's elo.
2. The username is not in the database, so the server creates a new player with this name and a base elo of 1000. 

The server then sends the client a packet of type kClientIdentification containing the client's username and elo. 
When the client receive this packet the client-application switches to the main-menu state.
This mechanism for returning the same type of packet guarantees that the client is properly logged in and identified, 
and that he can now use his application freely. 
It also makes it possible to reuse an existing packet type limit the size of the PacketType enumeration.

Joining a lobby.
===============================================================================
When the user presses the play button on the main menu, this sends a KJoinLobby packet to the server containing his username.
The server will look for the first free lobby and add to it a ClientData object containing the player's username and 
the port number on which the packets arrive.

Once the sucessfuly player has been added to the lobby, the server sends back a packet of type kJoinLobby 
so that the client is aware that it is indeed in a lobby, and the application switches to lobby GUI and state.

![Demo of two clients joining a lobby.](gifs/lobby.gif height=450)

Starting a game.
===============================================================================

When the server adds a second customer to a lobby, the lobby is complete and a game can be started. 
The server will create a packet of type kStartGame containing the value "true" and a player index for each client. 
The "true" value is used by the client to initialize its game, and the player index is used to differentiate between the players, 
giving them different colors (blue and red), for example.
The server also send a packet of type kNewTurn to the first player to enables him to play. 
The clients simply retreive the data of the packet, their application initialize a new game object, switch to game state
and the 8-ball pool game can start.

In-game packet communications.
===============================================================================

There is only two different packet types used in my gameplay logic. <br> 
You already know the first one which is a 
kNewTurn packet. This packet only contains a boolean to update the player logic that tells if the player can play or not.
This packet is send to the server which will resend it to the other client when a player has played and the physics simulation 
is finished (when all ball have a velocity lower than an epsilon value). <br> <br>

The second packet type is KCueBallVelocity. A packet of this type is sent to the server when a client has strikes the ball.
Something important is that the client don't simulates the physics right after striking the ball. It needs to wait for the 
server's response to updates the physics a deterministic amount of time to have the exact same simulation as the other client.
This server answer corresponds to antoher KCueBallVelocity sent to the two clients. So when a client receive this type of
packet, it will update the physics until all balls have a velocity greater than an epsilon value.

If the client don't wait for the server to simulate the physics, the would not have the same simulation. That's why
this response from the server is very important.

![Old version of my game when the clients don't wait the response from the server to 
simulate the physics. The more the game last, the more the physics desyncrhonization can be seen.](videos/physics_bug.mp4)

End of game and update of players' elo.
===============================================================================

Conclusion.
===============================================================================

My network API documentation.
===============================================================================

Sending packets.
===============================================================================

My protocol uses sf::Packet, which is an object that provides a safe and easy way of serializing data so that it can be sent 
over the network using sockets. 
As mentioned above, the first piece of data to be included in a packet is a PacketType. 
Let's take a look at how packets are sent from the client-side and the server-side

Client-side.
-------------------------------------------------------------------------------

Server-side.
-------------------------------------------------------------------------------


Receiving packets.
===============================================================================

<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style><script src="markdeep.min.js" charset="utf-8"></script><script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js?" charset="utf-8"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
